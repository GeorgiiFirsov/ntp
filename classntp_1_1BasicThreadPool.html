<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ntp: ntp::BasicThreadPool&lt; ThreadPoolTraits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ntp
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
   <div id="projectbrief">Threadpool library based on Win32 Threadool API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classntp_1_1BasicThreadPool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classntp_1_1BasicThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ntp::BasicThreadPool&lt; ThreadPoolTraits &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic threadpool class, that provides an interface for interacting with a pool.  
 <a href="classntp_1_1BasicThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="threadpool_8hpp_source.html">threadpool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a55102d27dc4a510fb4f8303c03582283"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a55102d27dc4a510fb4f8303c03582283">BasicThreadPool</a> (<a class="el" href="basic__callback_8hpp.html#a52d3f68ac97176db5960bbcd126cfb9e">details::test_cancel_t</a> test_cancel=details::DefaultTestCancel)</td></tr>
<tr class="memdesc:a55102d27dc4a510fb4f8303c03582283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classntp_1_1BasicThreadPool.html#a55102d27dc4a510fb4f8303c03582283">More...</a><br /></td></tr>
<tr class="separator:a55102d27dc4a510fb4f8303c03582283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b51f47c53cd6c419186690bf47e44f"><td class="memTemplParams" colspan="2">template&lt;typename  = std::enable_if_t&lt;std::is_same_v&lt;traits_t, details::CustomThreadPoolTraits&gt;&gt;&gt; </td></tr>
<tr class="memitem:a59b51f47c53cd6c419186690bf47e44f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a59b51f47c53cd6c419186690bf47e44f">BasicThreadPool</a> (DWORD min_threads, DWORD max_threads, <a class="el" href="basic__callback_8hpp.html#a52d3f68ac97176db5960bbcd126cfb9e">details::test_cancel_t</a> test_cancel=details::DefaultTestCancel)</td></tr>
<tr class="memdesc:a59b51f47c53cd6c419186690bf47e44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with the ability to set threadpool threads number.  <a href="classntp_1_1BasicThreadPool.html#a59b51f47c53cd6c419186690bf47e44f">More...</a><br /></td></tr>
<tr class="separator:a59b51f47c53cd6c419186690bf47e44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3d91351e32138b0857118e10817eae"><td class="memItemLeft" align="right" valign="top"><a id="a0c3d91351e32138b0857118e10817eae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a0c3d91351e32138b0857118e10817eae">~BasicThreadPool</a> ()</td></tr>
<tr class="memdesc:a0c3d91351e32138b0857118e10817eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor releases all forgotten (or not) resources via cleanup group. <br /></td></tr>
<tr class="separator:a0c3d91351e32138b0857118e10817eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0893ad8b6c5370273103c59c02e364e"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ab0893ad8b6c5370273103c59c02e364e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#ab0893ad8b6c5370273103c59c02e364e">SubmitWork</a> (Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab0893ad8b6c5370273103c59c02e364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a work callback into threadpool.  <a href="classntp_1_1BasicThreadPool.html#ab0893ad8b6c5370273103c59c02e364e">More...</a><br /></td></tr>
<tr class="separator:ab0893ad8b6c5370273103c59c02e364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af863331ccb4954ae13eed05205006f12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#af863331ccb4954ae13eed05205006f12">WaitWorks</a> () noexcept</td></tr>
<tr class="memdesc:af863331ccb4954ae13eed05205006f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all work callbacks are completed or cancellation is requested.  <a href="classntp_1_1BasicThreadPool.html#af863331ccb4954ae13eed05205006f12">More...</a><br /></td></tr>
<tr class="separator:af863331ccb4954ae13eed05205006f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798e87b63580ca2640474f100539ea34"><td class="memItemLeft" align="right" valign="top"><a id="a798e87b63580ca2640474f100539ea34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a798e87b63580ca2640474f100539ea34">CancelWorks</a> () noexcept</td></tr>
<tr class="memdesc:a798e87b63580ca2640474f100539ea34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all pending work callbacks. <br /></td></tr>
<tr class="separator:a798e87b63580ca2640474f100539ea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0a40d50b76c4a1f79f95ee8daaba0f"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a1b0a40d50b76c4a1f79f95ee8daaba0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="threadpool_8hpp.html#a306a370629fc82d8ff652969bcc709f6">wait_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">SubmitWait</a> (HANDLE wait_handle, const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1b0a40d50b76c4a1f79f95ee8daaba0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a wait callback into threadpool.  <a href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">More...</a><br /></td></tr>
<tr class="separator:a1b0a40d50b76c4a1f79f95ee8daaba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1c829eaffb7c10b01f2a9e566eb331"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:abb1c829eaffb7c10b01f2a9e566eb331"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#abb1c829eaffb7c10b01f2a9e566eb331">SubmitWait</a> (HANDLE wait_handle, Functor &amp;&amp;functor, Args &amp;&amp;... args) -&gt; std::enable_if_t&lt;!ntp::time::details::is_duration_v&lt; Functor &gt;, <a class="el" href="threadpool_8hpp.html#a306a370629fc82d8ff652969bcc709f6">wait_t</a> &gt;</td></tr>
<tr class="memdesc:abb1c829eaffb7c10b01f2a9e566eb331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a wait callback into threadpool (timeout never expires).  <a href="classntp_1_1BasicThreadPool.html#abb1c829eaffb7c10b01f2a9e566eb331">More...</a><br /></td></tr>
<tr class="separator:abb1c829eaffb7c10b01f2a9e566eb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9022977043d46ed1d2085210f42000f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a9022977043d46ed1d2085210f42000f0">CancelWait</a> (<a class="el" href="threadpool_8hpp.html#a306a370629fc82d8ff652969bcc709f6">wait_t</a> wait_object) noexcept</td></tr>
<tr class="memdesc:a9022977043d46ed1d2085210f42000f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel threadpool wait.  <a href="classntp_1_1BasicThreadPool.html#a9022977043d46ed1d2085210f42000f0">More...</a><br /></td></tr>
<tr class="separator:a9022977043d46ed1d2085210f42000f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4d90a7a2b14c41f5ad75af9c50247a"><td class="memItemLeft" align="right" valign="top"><a id="afd4d90a7a2b14c41f5ad75af9c50247a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#afd4d90a7a2b14c41f5ad75af9c50247a">CancelWaits</a> () noexcept</td></tr>
<tr class="memdesc:afd4d90a7a2b14c41f5ad75af9c50247a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all pending wait callbacks. <br /></td></tr>
<tr class="separator:afd4d90a7a2b14c41f5ad75af9c50247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf3211f92fe46ed6bd3d6b6eaab1adc"><td class="memTemplParams" colspan="2">template&lt;typename Rep1 , typename Period1 , typename Rep2 , typename Period2 , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:aadf3211f92fe46ed6bd3d6b6eaab1adc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a> (const std::chrono::duration&lt; Rep1, Period1 &gt; &amp;timeout, const std::chrono::duration&lt; Rep2, Period2 &gt; &amp;period, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aadf3211f92fe46ed6bd3d6b6eaab1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a threadpool timer object with a user-defined callback.  <a href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">More...</a><br /></td></tr>
<tr class="separator:aadf3211f92fe46ed6bd3d6b6eaab1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fcc5d8940a99da70b55d94aa9dc357"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:aa3fcc5d8940a99da70b55d94aa9dc357"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#aa3fcc5d8940a99da70b55d94aa9dc357">SubmitTimer</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout, Functor &amp;&amp;functor, Args &amp;&amp;... args) -&gt; std::enable_if_t&lt;!ntp::time::details::is_duration_v&lt; Functor &gt; &amp;&amp;!ntp::time::details::is_time_point_v&lt; Functor &gt;, <a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a> &gt;</td></tr>
<tr class="memdesc:aa3fcc5d8940a99da70b55d94aa9dc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a non-periodic threadpool timer object with a user-defined callback.  <a href="classntp_1_1BasicThreadPool.html#aa3fcc5d8940a99da70b55d94aa9dc357">More...</a><br /></td></tr>
<tr class="separator:aa3fcc5d8940a99da70b55d94aa9dc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51fa4b873d600ba3f37728b477ef152"><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename Rep , typename Period , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ac51fa4b873d600ba3f37728b477ef152"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#ac51fa4b873d600ba3f37728b477ef152">SubmitTimer</a> (const <a class="el" href="time_8hpp.html#ab1ea4e25b1332d473030000e6de57b8e">ntp::time::deadline_t</a>&lt; Duration &gt; &amp;deadline, const std::chrono::duration&lt; Rep, Period &gt; &amp;period, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac51fa4b873d600ba3f37728b477ef152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a threadpool deadline timer object with a user-defined callback.  <a href="classntp_1_1BasicThreadPool.html#ac51fa4b873d600ba3f37728b477ef152">More...</a><br /></td></tr>
<tr class="separator:ac51fa4b873d600ba3f37728b477ef152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ee566487f5d7d430d94ccf73254b9"><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a7e3ee566487f5d7d430d94ccf73254b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a7e3ee566487f5d7d430d94ccf73254b9">SubmitTimer</a> (const <a class="el" href="time_8hpp.html#ab1ea4e25b1332d473030000e6de57b8e">ntp::time::deadline_t</a>&lt; Duration &gt; &amp;deadline, Functor &amp;&amp;functor, Args &amp;&amp;... args) -&gt; std::enable_if_t&lt;!ntp::time::details::is_duration_v&lt; Functor &gt; &amp;&amp;!ntp::time::details::is_time_point_v&lt; Functor &gt;, <a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a> &gt;</td></tr>
<tr class="memdesc:a7e3ee566487f5d7d430d94ccf73254b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a non-periodic threadpool deadline timer object with a user-defined callback.  <a href="classntp_1_1BasicThreadPool.html#a7e3ee566487f5d7d430d94ccf73254b9">More...</a><br /></td></tr>
<tr class="separator:a7e3ee566487f5d7d430d94ccf73254b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbf682754b0d3070eb2b5ec13ff2631"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:acdbf682754b0d3070eb2b5ec13ff2631"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#acdbf682754b0d3070eb2b5ec13ff2631">ReplaceTimer</a> (<a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a> timer_object, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acdbf682754b0d3070eb2b5ec13ff2631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an existing timer callback in threadpool. This method cannot be called concurrently for the same timer object.  <a href="classntp_1_1BasicThreadPool.html#acdbf682754b0d3070eb2b5ec13ff2631">More...</a><br /></td></tr>
<tr class="separator:acdbf682754b0d3070eb2b5ec13ff2631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93452e89aa71e991a3c5b812c9712a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a93452e89aa71e991a3c5b812c9712a7b">CancelTimer</a> (<a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a> timer_object) noexcept</td></tr>
<tr class="memdesc:a93452e89aa71e991a3c5b812c9712a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel threadpool timer.  <a href="classntp_1_1BasicThreadPool.html#a93452e89aa71e991a3c5b812c9712a7b">More...</a><br /></td></tr>
<tr class="separator:a93452e89aa71e991a3c5b812c9712a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f0961e4217d05f26e7fd669402a3a"><td class="memItemLeft" align="right" valign="top"><a id="ad89f0961e4217d05f26e7fd669402a3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#ad89f0961e4217d05f26e7fd669402a3a">CancelTimers</a> () noexcept</td></tr>
<tr class="memdesc:ad89f0961e4217d05f26e7fd669402a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all pending timer callbacks. <br /></td></tr>
<tr class="separator:ad89f0961e4217d05f26e7fd669402a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896b5331d3aaa49a2d9a128c2ac91e9a"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a896b5331d3aaa49a2d9a128c2ac91e9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="threadpool_8hpp.html#aba881202ec99a5f486f3fd0f3d7446b9">io_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a">SubmitIo</a> (HANDLE io_handle, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a896b5331d3aaa49a2d9a128c2ac91e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a threadpool IO object with a user-defined callback.  <a href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a">More...</a><br /></td></tr>
<tr class="separator:a896b5331d3aaa49a2d9a128c2ac91e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568ff5fba7cebe6ad9dd7955e942c01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a568ff5fba7cebe6ad9dd7955e942c01a">CancelIo</a> (<a class="el" href="threadpool_8hpp.html#aba881202ec99a5f486f3fd0f3d7446b9">io_t</a> io_object) noexcept</td></tr>
<tr class="memdesc:a568ff5fba7cebe6ad9dd7955e942c01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel threadpool IO.  <a href="classntp_1_1BasicThreadPool.html#a568ff5fba7cebe6ad9dd7955e942c01a">More...</a><br /></td></tr>
<tr class="separator:a568ff5fba7cebe6ad9dd7955e942c01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fee13ef91c8688336a5de8358931b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a87fee13ef91c8688336a5de8358931b2">AbortIo</a> (<a class="el" href="threadpool_8hpp.html#aba881202ec99a5f486f3fd0f3d7446b9">io_t</a> io_object) noexcept</td></tr>
<tr class="memdesc:a87fee13ef91c8688336a5de8358931b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel threadpool IO if async IO failed to start.  <a href="classntp_1_1BasicThreadPool.html#a87fee13ef91c8688336a5de8358931b2">More...</a><br /></td></tr>
<tr class="separator:a87fee13ef91c8688336a5de8358931b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2a8ee6326ab9de68fc887762c421e"><td class="memItemLeft" align="right" valign="top"><a id="a4ef2a8ee6326ab9de68fc887762c421e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#a4ef2a8ee6326ab9de68fc887762c421e">CancelIos</a> () noexcept</td></tr>
<tr class="memdesc:a4ef2a8ee6326ab9de68fc887762c421e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all pending IO callbacks. <br /></td></tr>
<tr class="separator:a4ef2a8ee6326ab9de68fc887762c421e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefae25ab34cf134904e46b7f67c0ddc1"><td class="memItemLeft" align="right" valign="top"><a id="aefae25ab34cf134904e46b7f67c0ddc1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classntp_1_1BasicThreadPool.html#aefae25ab34cf134904e46b7f67c0ddc1">CancelAllCallbacks</a> () noexcept</td></tr>
<tr class="memdesc:aefae25ab34cf134904e46b7f67c0ddc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all pending callbacks (of any kind). <br /></td></tr>
<tr class="separator:aefae25ab34cf134904e46b7f67c0ddc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ThreadPoolTraits&gt;<br />
class ntp::BasicThreadPool&lt; ThreadPoolTraits &gt;</h3>

<p>Basic threadpool class, that provides an interface for interacting with a pool. </p>
<p>Class needs to be instantiated with threadpool traits, that define which threadpool to use: system-default or cutom. One can write its own threadpool traits if necessary.</p>
<p>You can submit 4 different object types into threadpool:</p><ul>
<li>Work objects, that execute your arbitrary callback immediately.</li>
<li>Wait objects, that execute your arbitrary callback, when specified handle becomes signaled or timeout expires.</li>
<li>Timer objects, that execute your arbitrary callback, when timer expires. They may be scheduled for periodical calls. You may exchange callback submitted earlier with a new one, and next time timer will call an updated one.</li>
<li>IO objects, that execute your arbitrary callback, when asynchronous IO is completed.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ThreadPoolTraits</td><td>Threadpool traits, that define actual implementation internals. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a55102d27dc4a510fb4f8303c03582283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55102d27dc4a510fb4f8303c03582283">&#9670;&nbsp;</a></span>BasicThreadPool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::<a class="el" href="classntp_1_1BasicThreadPool.html">BasicThreadPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__callback_8hpp.html#a52d3f68ac97176db5960bbcd126cfb9e">details::test_cancel_t</a>&#160;</td>
          <td class="paramname"><em>test_cancel</em> = <code>details::DefaultTestCancel</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes stateful threadpool traits and cleanup group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_cancel</td><td>Cancellation test function (defaulted to ntp::details::DefaultTestCancel). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b51f47c53cd6c419186690bf47e44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b51f47c53cd6c419186690bf47e44f">&#9670;&nbsp;</a></span>BasicThreadPool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename  = std::enable_if_t&lt;std::is_same_v&lt;traits_t, details::CustomThreadPoolTraits&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::<a class="el" href="classntp_1_1BasicThreadPool.html">BasicThreadPool</a> </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>min_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basic__callback_8hpp.html#a52d3f68ac97176db5960bbcd126cfb9e">details::test_cancel_t</a>&#160;</td>
          <td class="paramname"><em>test_cancel</em> = <code>details::DefaultTestCancel</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with the ability to set threadpool threads number. </p>
<p>This constructor is available only for ntp::BasicThreadPool&lt;details::CustomThreadPoolTraits&gt; specialization. For the description of parameters refer to <a class="el" href="classntp_1_1details_1_1CustomThreadPoolTraits.html" title="Traits for a custom threadpool.">ntp::details::CustomThreadPoolTraits</a> description.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::ThreadPool</a>(1, 16); <span class="comment">// Use up to 16 threads in thread pool</span></div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a></div><div class="ttdoc">Basic threadpool class, that provides an interface for interacting with a pool.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:189</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_threads</td><td>Minimum number of threads. </td></tr>
    <tr><td class="paramname">max_threads</td><td>Maximum number of threads. </td></tr>
    <tr><td class="paramname">test_cancel</td><td>Cancellation test function (defaulted to ntp::details::DefaultTestCancel). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a87fee13ef91c8688336a5de8358931b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fee13ef91c8688336a5de8358931b2">&#9670;&nbsp;</a></span>AbortIo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::AbortIo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadpool_8hpp.html#aba881202ec99a5f486f3fd0f3d7446b9">io_t</a>&#160;</td>
          <td class="paramname"><em>io_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel threadpool IO if async IO failed to start. </p>
<p>For usage example refer to <a class="el" href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a" title="Submits a threadpool IO object with a user-defined callback.">ntp::BasicThreadPool::SubmitIo</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_object</td><td>Handle for an existing IO object (obtained from <a class="el" href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a" title="Submits a threadpool IO object with a user-defined callback.">ntp::BasicThreadPool::SubmitIo</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a568ff5fba7cebe6ad9dd7955e942c01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568ff5fba7cebe6ad9dd7955e942c01a">&#9670;&nbsp;</a></span>CancelIo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::CancelIo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadpool_8hpp.html#aba881202ec99a5f486f3fd0f3d7446b9">io_t</a>&#160;</td>
          <td class="paramname"><em>io_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel threadpool IO. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> io = pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a">SubmitIo</a>(file, [] (LPVOID overlapped, ULONG result, ULONG_PTR bytes_transferred) { ... });</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// You may want not to call callback on IO completion anymore, but IO didn&#39;t fail.</span></div>
<div class="line"><span class="comment">// In this case you just need to cancel it</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a568ff5fba7cebe6ad9dd7955e942c01a">CancelIo</a>(io);</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_a568ff5fba7cebe6ad9dd7955e942c01a"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#a568ff5fba7cebe6ad9dd7955e942c01a">ntp::BasicThreadPool::CancelIo</a></div><div class="ttdeci">void CancelIo(io_t io_object) noexcept</div><div class="ttdoc">Cancel threadpool IO.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:723</div></div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_a896b5331d3aaa49a2d9a128c2ac91e9a"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a">ntp::BasicThreadPool::SubmitIo</a></div><div class="ttdeci">io_t SubmitIo(HANDLE io_handle, Functor &amp;&amp;functor, Args &amp;&amp;... args)</div><div class="ttdoc">Submits a threadpool IO object with a user-defined callback.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:699</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_object</td><td>Handle for an existing IO object (obtained from <a class="el" href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a" title="Submits a threadpool IO object with a user-defined callback.">ntp::BasicThreadPool::SubmitIo</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93452e89aa71e991a3c5b812c9712a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93452e89aa71e991a3c5b812c9712a7b">&#9670;&nbsp;</a></span>CancelTimer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::CancelTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a>&#160;</td>
          <td class="paramname"><em>timer_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel threadpool timer. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> timer = pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(30s, 10s, [] () { ... });</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// You may need to stop timer to trigger each 10 seconds, sou you may just cancel it!</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a93452e89aa71e991a3c5b812c9712a7b">CancelTimer</a>(timer);</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_a93452e89aa71e991a3c5b812c9712a7b"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#a93452e89aa71e991a3c5b812c9712a7b">ntp::BasicThreadPool::CancelTimer</a></div><div class="ttdeci">void CancelTimer(timer_t timer_object) noexcept</div><div class="ttdoc">Cancel threadpool timer.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:641</div></div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_aadf3211f92fe46ed6bd3d6b6eaab1adc"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">ntp::BasicThreadPool::SubmitTimer</a></div><div class="ttdeci">timer_t SubmitTimer(const std::chrono::duration&lt; Rep1, Period1 &gt; &amp;timeout, const std::chrono::duration&lt; Rep2, Period2 &gt; &amp;period, Functor &amp;&amp;functor, Args &amp;&amp;... args)</div><div class="ttdoc">Submits a threadpool timer object with a user-defined callback.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:474</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_object</td><td>Handle for an existing timer object (obtained from <a class="el" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc" title="Submits a threadpool timer object with a user-defined callback.">ntp::BasicThreadPool::SubmitTimer</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9022977043d46ed1d2085210f42000f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9022977043d46ed1d2085210f42000f0">&#9670;&nbsp;</a></span>CancelWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::CancelWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadpool_8hpp.html#a306a370629fc82d8ff652969bcc709f6">wait_t</a>&#160;</td>
          <td class="paramname"><em>wait_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel threadpool wait. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> wait = pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">SubmitWait</a>(event, [] () { ... });</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Suppose you don&#39;t need to wait for callback and execute </span></div>
<div class="line"><span class="comment">// a function anymore. You can just cancel it!</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a9022977043d46ed1d2085210f42000f0">CancelWait</a>(wait);</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_a1b0a40d50b76c4a1f79f95ee8daaba0f"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">ntp::BasicThreadPool::SubmitWait</a></div><div class="ttdeci">wait_t SubmitWait(HANDLE wait_handle, const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout, Functor &amp;&amp;functor, Args &amp;&amp;... args)</div><div class="ttdoc">Submits a wait callback into threadpool.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:379</div></div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_a9022977043d46ed1d2085210f42000f0"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#a9022977043d46ed1d2085210f42000f0">ntp::BasicThreadPool::CancelWait</a></div><div class="ttdeci">void CancelWait(wait_t wait_object) noexcept</div><div class="ttdoc">Cancel threadpool wait.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:441</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_object</td><td>Handle for an existing wait object (obtained from <a class="el" href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f" title="Submits a wait callback into threadpool.">ntp::BasicThreadPool::SubmitWait</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdbf682754b0d3070eb2b5ec13ff2631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbf682754b0d3070eb2b5ec13ff2631">&#9670;&nbsp;</a></span>ReplaceTimer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a> <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::ReplaceTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a>&#160;</td>
          <td class="paramname"><em>timer_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces an existing timer callback in threadpool. This method cannot be called concurrently for the same timer object. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> timer = pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(30s, 10s, [] () { ... });</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// You may need to replace a callback, that will be called when timer expires,</span></div>
<div class="line"><span class="comment">// so you just replace it by its handle</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#acdbf682754b0d3070eb2b5ec13ff2631">ReplaceTimer</a>(timer, [] (<span class="keywordtype">size_t</span> param1, <span class="keywordtype">int</span> param2) { ... }, </div>
<div class="line">    you_can_even_pass, another_arguments);</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_acdbf682754b0d3070eb2b5ec13ff2631"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#acdbf682754b0d3070eb2b5ec13ff2631">ntp::BasicThreadPool::ReplaceTimer</a></div><div class="ttdeci">timer_t ReplaceTimer(timer_t timer_object, Functor &amp;&amp;functor, Args &amp;&amp;... args)</div><div class="ttdoc">Replaces an existing timer callback in threadpool. This method cannot be called concurrently for the ...</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:618</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_object</td><td>Handle for an existing timer object (obtained from <a class="el" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc" title="Submits a threadpool timer object with a user-defined callback.">ntp::BasicThreadPool::SubmitTimer</a>). </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classntp_1_1exception_1_1Win32Exception.html" title="Wrapper for Win32 error code, that has C++ interface.">exception::Win32Exception</a></td><td>If the specified handle is not present in threadpool or is corrupt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the same timer object. </dd></dl>

</div>
</div>
<a id="a896b5331d3aaa49a2d9a128c2ac91e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896b5331d3aaa49a2d9a128c2ac91e9a">&#9670;&nbsp;</a></span>SubmitIo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="threadpool_8hpp.html#aba881202ec99a5f486f3fd0f3d7446b9">io_t</a> <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitIo </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>io_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a threadpool IO object with a user-defined callback. </p>
<p>If after call to this function async IO failed to start you MUST call <a class="el" href="classntp_1_1BasicThreadPool.html#a87fee13ef91c8688336a5de8358931b2" title="Cancel threadpool IO if async IO failed to start.">ntp::BasicThreadPool::AbortIo</a> to prevent memory leaks).</p>
<p>Usage example: </p><div class="fragment"><div class="line">ATL::CAtlFile file;</div>
<div class="line">file.Create(..., FILE_FLAG_OVERLAPPED, ...);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> io = pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a896b5331d3aaa49a2d9a128c2ac91e9a">SubmitIo</a>(file, [] (LPVOID overlapped, ULONG result, ULONG_PTR bytes_transferred) {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Pointer passed as overlapped structure to WriteFile is in overlapped parameter</span></div>
<div class="line">    <span class="comment">// Result of async IO operation is in result parameter</span></div>
<div class="line">    <span class="comment">// Number of bytes transferred during the last IO is in bytes_transferred parameter</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">OVERLAPPED ovl = {};</div>
<div class="line">HRESULT hr = file.Write(buffer, buffer_size, &amp;ovl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Error occurred. We need to abort thread pool IO here</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    </div>
<div class="line">    pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a87fee13ef91c8688336a5de8358931b2">AbortIo</a>(io);</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Cannot write to file&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_a87fee13ef91c8688336a5de8358931b2"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#a87fee13ef91c8688336a5de8358931b2">ntp::BasicThreadPool::AbortIo</a></div><div class="ttdeci">void AbortIo(io_t io_object) noexcept</div><div class="ttdoc">Cancel threadpool IO if async IO failed to start.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:732</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_handle</td><td>Handle of and object, wchich asynchronous IO is performed on. </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. However, it MUST accept the following parameters as the first, second and third ones (second, third and fourth if <code>PTP_CALLBACK_INSTANCE</code> is passed):<ul>
<li><code>LPVOID</code> overlapped - A pointer to a variable that receives the address of the OVERLAPPED structure that was specified when the completed IO operation was started.</li>
<li><code>ULONG</code> result - The result of the I/O operation. If the I/O is successful, this parameter is NO_ERROR. Otherwise, this parameter is one of the system error codes.</li>
<li><code>ULONG_PTR</code> bytes_transferred - The number of bytes transferred during the IO operation that has completed. </li>
</ul>
</td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created IO object. </dd></dl>

</div>
</div>
<a id="ac51fa4b873d600ba3f37728b477ef152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51fa4b873d600ba3f37728b477ef152">&#9670;&nbsp;</a></span>SubmitTimer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Duration , typename Rep , typename Period , typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="time_8hpp.html#ab1ea4e25b1332d473030000e6de57b8e">ntp::time::deadline_t</a>&lt; Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>deadline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a threadpool deadline timer object with a user-defined callback. </p>
<p>If deadline is already gone, timer expires immediately.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> now = ntp::time::deadline_clock_t::now();</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(now + 40min, 10s, [] () {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This timer will be triggered after 40 minutes from now and then</span></div>
<div class="line">    <span class="comment">// will be triggered repeatedly every 10 seconds</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(now - 20s, 10s, [] () {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This timer will be triggered immediately (since deadline is already gone) </span></div>
<div class="line">    <span class="comment">// and after that will be triggered repeatedly every 10 seconds</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deadline</td><td>A specific point in time, which the timer will expire at for the first time. </td></tr>
    <tr><td class="paramname">period</td><td>Period of the timer. Callback will be triggered after each such interval is elapsed. Pass zero, if you want to create a timer, that will be triggered only once. </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created timer object. </dd></dl>

</div>
</div>
<a id="a7e3ee566487f5d7d430d94ccf73254b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ee566487f5d7d430d94ccf73254b9">&#9670;&nbsp;</a></span>SubmitTimer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Duration , typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="time_8hpp.html#ab1ea4e25b1332d473030000e6de57b8e">ntp::time::deadline_t</a>&lt; Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>deadline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;!ntp::time::details::is_duration_v&lt;Functor&gt; &amp;&amp; !ntp::time::details::is_time_point_v&lt;Functor&gt;, <a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a>&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a non-periodic threadpool deadline timer object with a user-defined callback. </p>
<p>If deadline is already gone, timer expires immediately.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> now = ntp::time::deadline_clock_t::now();</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(now + 40min, [] () {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This timer will be triggered only once after 40 minutes from now</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(now - 20s, [] () {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This timer will be triggered only once immediately (since deadline is already gone)</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deadline</td><td>A specific point in time, which the timer will expire at for the first time. </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created timer object. </dd></dl>

</div>
</div>
<a id="aa3fcc5d8940a99da70b55d94aa9dc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fcc5d8940a99da70b55d94aa9dc357">&#9670;&nbsp;</a></span>SubmitTimer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitTimer </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;!ntp::time::details::is_duration_v&lt;Functor&gt; &amp;&amp; !ntp::time::details::is_time_point_v&lt;Functor&gt;, <a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a>&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a non-periodic threadpool timer object with a user-defined callback. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(20s, [] () {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This timer will be triggered only once after 20 seconds</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout after which timer object calls the callback for the first time. </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created timer object. </dd></dl>

</div>
</div>
<a id="aadf3211f92fe46ed6bd3d6b6eaab1adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf3211f92fe46ed6bd3d6b6eaab1adc">&#9670;&nbsp;</a></span>SubmitTimer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Rep1 , typename Period1 , typename Rep2 , typename Period2 , typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="threadpool_8hpp.html#a01e95d988314d46fbf6ed54dbc8cf9e6">timer_t</a> <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitTimer </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep1, Period1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep2, Period2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a threadpool timer object with a user-defined callback. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#aadf3211f92fe46ed6bd3d6b6eaab1adc">SubmitTimer</a>(20s, 10s, [] () {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This timer will be triggered after 20 seconds and </span></div>
<div class="line">    <span class="comment">// then every 10 seconds</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout after which timer object calls the callback for the first time. </td></tr>
    <tr><td class="paramname">period</td><td>Period of the timer. Callback will be triggered after each such interval is elapsed. Pass zero, if you want to create a timer, that will be triggered only once. </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created timer object. </dd></dl>

</div>
</div>
<a id="a1b0a40d50b76c4a1f79f95ee8daaba0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0a40d50b76c4a1f79f95ee8daaba0f">&#9670;&nbsp;</a></span>SubmitWait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="threadpool_8hpp.html#a306a370629fc82d8ff652969bcc709f6">wait_t</a> <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitWait </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>wait_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a wait callback into threadpool. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line">HANDLE <span class="keyword">event</span> = ::CreateEvent(<span class="keyword">nullptr</span>, TRUE, FALSE, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">SubmitWait</a>(event, 20min, [] (TP_WAIT_RESULT wait_result) {</div>
<div class="line">    <span class="keywordflow">if</span> (WAIT_OBJECT_0 == wait_result)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Wait completed</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Timeout </span></div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">SubmitWait</a>(event, 30min, [custom_dll] (PTP_CALLBACK_INSTANCE instance, TP_WAIT_RESULT wait_result) {</div>
<div class="line">    <span class="keywordflow">if</span> (WAIT_OBJECT_0 != wait_result)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Suppose we don&#39;t need a dll anymore, if event is not signaled in 30 minutes</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        </div>
<div class="line">        FreeLibraryWhenCallbackReturns(instance, custom_dll);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_handle</td><td>Handle to wait for. May be any handle, that you can pass to <code>WaitForSingleObject</code>. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout while wait object waits for the specified handle (pass ntp::time::max_native_duration for infinite wait timeout). </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. However, it MUST accept the following parameter as the first one (second if <code>PTP_CALLBACK_INSTANCE</code> is passed):<ul>
<li><code>TP_WAIT_RESULT</code> wait_result - The result of the wait operation. This parameter can be one of the following values from <code>WaitForMultipleObjects</code>: <code>WAIT_OBJECT_0</code>, <code>WAIT_TIMEOUT</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created wait object. </dd></dl>

</div>
</div>
<a id="abb1c829eaffb7c10b01f2a9e566eb331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1c829eaffb7c10b01f2a9e566eb331">&#9670;&nbsp;</a></span>SubmitWait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitWait </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>wait_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;!ntp::time::details::is_duration_v&lt;Functor&gt;, <a class="el" href="threadpool_8hpp.html#a306a370629fc82d8ff652969bcc709f6">wait_t</a>&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a wait callback into threadpool (timeout never expires). </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line">HANDLE <span class="keyword">event</span> = ::CreateEvent(<span class="keyword">nullptr</span>, TRUE, FALSE, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#a1b0a40d50b76c4a1f79f95ee8daaba0f">SubmitWait</a>(event, [] (TP_WAIT_RESULT wait_result) {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Wait result SHOULD be WAIT_OBJECT_0 here (as for 13 of December, 2022), but passed to the </span></div>
<div class="line">    <span class="comment">// callable to handle potential future changes.</span></div>
<div class="line">    <span class="comment">// This callback is called only if event is signaled, because it waits for it infinitely.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_handle</td><td>Handle to wait for. May be any handle, that you can pass to <code>WaitForSingleObject</code>. </td></tr>
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. However, it MUST accept the following parameter as the first one (second if <code>PTP_CALLBACK_INSTANCE</code> is passed):<ul>
<li><code>TP_WAIT_RESULT</code> wait_result - The result of the wait operation. This parameter can be one of the following values from <code>WaitForMultipleObjects</code>: <code>WAIT_OBJECT_0</code>, <code>WAIT_TIMEOUT</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for created wait object. </dd></dl>

</div>
</div>
<a id="ab0893ad8b6c5370273103c59c02e364e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0893ad8b6c5370273103c59c02e364e">&#9670;&nbsp;</a></span>SubmitWork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::SubmitWork </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a work callback into threadpool. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#ab0893ad8b6c5370273103c59c02e364e">SubmitWork</a>([] (<span class="keyword">const</span> std::string&amp; parameter1, <span class="keywordtype">size_t</span> parameter2) {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Parameter passed_by_ref will not be copied because of std::cref,</span></div>
<div class="line">    <span class="comment">// whereas passed_by_value parameter will be copied into an internal</span></div>
<div class="line">    <span class="comment">// callable wrapper.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">}, std::cref(passed_by_ref), passed_by_value);</div>
<div class="line"> </div>
<div class="line">pool.<a class="code" href="classntp_1_1BasicThreadPool.html#ab0893ad8b6c5370273103c59c02e364e">SubmitWork</a>([event_handle] (PTP_CALLBACK_INSTANCE instance) {</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Callback can accept PTP_CALLBACK_INSTANCE as its first parameter,</span></div>
<div class="line">    <span class="comment">// but it is optional, so you are free not to pass it</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">});</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_ab0893ad8b6c5370273103c59c02e364e"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#ab0893ad8b6c5370273103c59c02e364e">ntp::BasicThreadPool::SubmitWork</a></div><div class="ttdeci">void SubmitWork(Functor &amp;&amp;functor, Args &amp;&amp;... args)</div><div class="ttdoc">Submits a work callback into threadpool.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:294</div></div>
</div><!-- fragment --><p>There may be some conflictine situations with a <code>PTP_CALLBACK_INSTANCE</code> custom parameter, but usually you don't have to pass it as your own parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Type of callable to invoke in threadpool. </td></tr>
    <tr><td class="paramname">Args...</td><td>Types of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>Callable to invoke. It MAY accept <code>PTP_CALLBACK_INSTANCE</code> as its first parameter. If you don't need it, you just don't pass it. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass into callable. They will be copied into wrapper by default. You schould use <code>std::ref</code> or <code>std::cref</code> to pass a parameter by reference, but you must guarantee the parameter's validity until the callback is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af863331ccb4954ae13eed05205006f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af863331ccb4954ae13eed05205006f12">&#9670;&nbsp;</a></span>WaitWorks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ThreadPoolTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classntp_1_1BasicThreadPool.html">ntp::BasicThreadPool</a>&lt; ThreadPoolTraits &gt;::WaitWorks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until all work callbacks are completed or cancellation is requested. </p>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="classntp_1_1BasicThreadPool.html">ntp::SystemThreadPool</a> pool;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Submit some callbacks to thread pool</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!pool.<a class="code" href="classntp_1_1BasicThreadPool.html#af863331ccb4954ae13eed05205006f12">WaitWorks</a>())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Cancellation was requested, some tasks may be incomplete.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">    HandleIncompleteProcessing();</div>
<div class="line">}</div>
<div class="ttc" id="aclassntp_1_1BasicThreadPool_html_af863331ccb4954ae13eed05205006f12"><div class="ttname"><a href="classntp_1_1BasicThreadPool.html#af863331ccb4954ae13eed05205006f12">ntp::BasicThreadPool::WaitWorks</a></div><div class="ttdeci">bool WaitWorks() noexcept</div><div class="ttdoc">Waits until all work callbacks are completed or cancellation is requested.</div><div class="ttdef"><b>Definition:</b> threadpool.hpp:324</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true if all callbacks are completed, false if cancellation occurred while waiting for callbacks. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ntp/include/pool/<a class="el" href="threadpool_8hpp_source.html">threadpool.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ntp</b></li><li class="navelem"><a class="el" href="classntp_1_1BasicThreadPool.html">BasicThreadPool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
